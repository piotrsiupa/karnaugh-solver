#include "./info.hh"

#include <iostream>


void printShortHelp()
{
	std::cout <<
			"This program performs a logic function minimization of a function described as\na list of minterms and don't-cares to a SOP form and after that it performs\na common subexpression elimination.\n"
			"It searches for a solution that uses a minimal number of logic gates.\n"
			"\n"
			"Usage:\tkarnaugh [OPTIONS...] [--] [INPUT_FILE]\n"
			"Options:\n"
			" general:\n"
			"    -h, --help\t\t- Print full help text, including lists of option\n\t\t\t  arguments and description of the input format.\n"
			"    -H, --help-options\t- Print shortened help text, truncated at options.\n"
			"    -v, --version\t- Print version information.\n"
			" user interface:\n"
			"    -p, --prompt[=X]\t- Set whether hints are shown when the input is read.\n\t\t\t  "
						"Valid values are \"always\", \"never\" and \"default\".\n\t\t\t  "
						"(No value means \"always\".) "
						"By default, hints are shown\n\t\t\t  only when input is read from a TTY.\n"
			"    -P, --no-prompt\t- Same as `--prompt=never`.\n"
			"    -s, --status[=X]\t- Set whether things like the current operation,\n\t\t\t  progress bar, ET, ETA and so on are shown.\n\t\t\t  "
						"Valid values are \"always\", \"never\" and \"default\".\n\t\t\t  "
						"(No value means \"always\".) "
						"By default, they are shown\n\t\t\t  only when the stderr is a TTY.\n"
			"    -S, --no-status\t- Same as `--status=never`.\n"
			" output:\n"
			"    -f, --format=X\t- Set the output format. (See \"Output formats\".)\n\t\t\t  "
						"(Mathematical formats imply `--no-optimize`.)\n"
			"    -n, --name=X\t- Set module name for Verilog output or entity name for\n\t\t\t  VHDL output or class name for C++ output.\n\t\t\t  "
						"(By default, the name of the input file is used,\n\t\t\t  or \"Karnaugh\" if input is read from stdin.)\n"
			" 1st stage - finding prime implicants:\n"
			"    -i, --i-heuristic\t- Set heuristic to use for generating prime implicants.\n\t\t\t  "
						"(See \"Prime implicants heuristics\".)\n"
			"    -g, --greedy-refine\t- Set number of attempts to improve implicants found by\n\t\t\t  the greedy heuristic. "
						"(0..32, -1 means auto (default))\n\t\t\t  "
						"Both the time cost and the gained improvement of an\n\t\t\t  attempt decrese with number of attempts but the time\n\t\t\t  cost decreases slower.\n\t\t\t  "
						"(See \"Prime implicants heuristics\".)\n"
			" 2nd stage - generating solutions:\n"
			"    -z, --s-heuristic\t- Set heuristic to use for generating solutions.\n\t\t\t  "
						"(See \"Solutions heuristics\".)\n"
			"    -m, --max-solutions\t- Limits solutions that are considered at each step of\n\t\t\t  the Petrick's method if limiting is enabled. "
						"Excess\n\t\t\t  solutions are chosen with a heuristic and removed.\n\t\t\t  "
						"`0` is an automatically chosen limit (default).\n\t\t\t  "
						"(See \"Solutions heuristics\".)\n"
			" 3rd stage - common subexpression elimination:\n"
			"    -O, --no-optimize\t- Skip the common subexpression elimination optimization\n\t\t\t  and show only a raw solution for each function.\n"
			"    -e, --cse-heuristic\t- Set heuristic for eliminating common subexpressions.\n\t\t\t  "
						"(See \"Common subexpression elimination heuristics\".)\n"
		;
}

void printHelp()
{
	printShortHelp();
	std::cout <<
			"\n"
			"\n"
			"Output formats:\n"
			"\thuman-long\t- The default format which displays all the information\n\t\t\t  in a human-readable way.\n"
			"\thuman\t\t- A format similar to \"human-long\" but it without the\n\t\t\t  graphical representations of Karnaugh maps which\n\t\t\t  normally take most of the vertical space.\n"
			"\thuman-short\t- A minimalistic result of the program without any\n\t\t\t  additional fluff, in a human-readable way.\n"
			"\tgraph\t\t- `human-short` as a graph in the DOT language.\n"
			"\treduced-graph\t- Similar `graph` but input nodes are omitted for\n\t\t\t  readability. (Instead, they are shown as labels.)\n"
			"\tverilog\t\t- A Verilog module.\n"
			"\tvhdl\t\t- A VHDL entity.\n"
			"\tcpp\t\t- A C++ class (both a functor and static functions).\n"
			"\tmath-formal\t- The formal mathematical notation. (It uses Unicode.)\n"
			"\tmath-ascii\t- A notation like \"math-formal\" but it uses only ASCII.\n"
			"\tmath-prog\t- A mathematical notation with programming operators.\n"
			"\tmath-names\t- A mathematical notation that uses names of operators.\n"
			"\tgate-costs\t- Only gate costs. (Useful mostly for development.)\n"
			"\n"
			"\n"
			"Prime implicants heuristics:\n"
			"\tauto\t\t- Chooses the best method that is fast enough. "
						"(default)\n"
			"\tbrute-force\t- No heuristic; find all prime implicants. It's very\n\t\t\t  slow but it gives the best results if you won't run\n\t\t\t  out of RAM. "
						"(It can be comfortably used up to 20\n\t\t\t  inputs and for 24 it takes over 21 GB and 10 minutes.)\n"
			"\tgreedy\t\t- Use greedy algorithm to list prime implicants, trying\n\t\t\t  to get mostly a set of essential ones.\n\t\t\t  "
						"(very fast and memory efficient)\n\t\t\t  "
						"(See the option `--greedy-refine`.)\n"
			"\n"
			"\n"
			"Solutions heuristics:\n"
			"\tauto\t- Chooses the best method that is fast enough. "
						"(default)\n"
			"\tpetrick\t- Petrick's Method. It will find the best solution but its non-\n\t\t  -polynomial time causes it to be viable only when the number\n\t\t  of inputs is very small. "
						"(It should work for <=6 inputs.)\n\t\t  "
						"For bigger cases you'll either run out of RAM and will wait\n\t\t  years for the result (depending on how much RAM you have).\n"
			"\tlimited\t- It's the same Petrick's Method as the previous one but the\n\t\t  amount of solutions that can be stored at one time is limited\n\t\t  so they won't get out of control. "
						"Only N solutions that look\n\t\t  the best at the moment are kept, which tends to get a decent\n\t\t  end result. "
						"The time needed is loosely proportional to N.\n\t\t  "
						"However, N=1 is a special case with a simpler algorithm and it\n\t\t  is about 60% faster.\n\t\t  "
						"(See the option `--max-solutions`.)\n"
			"\tgreedy\t- It just takes the first available solution for each minterm.\n\t\t  "
						"It's extremely fast and it takes very little memory but the\n\t\t  final solution is worse than for the other heuristics.\n"
			"\trough\t- Currently rather useless because it's slower than `greedy` and\n\t\t  it gives worse results. (WIP)\n"
			"\n"
			"\n"
			"Common subexpression elimination heuristics:\n"
			"\tbrute-force\t- It checks all possible graphs of expressions which\n\t\t\t  guarantees the optimal result but it takes some much\n\t\t\t  time that it's viable only for very small solutions.\n"
			"\texhuastive\t- It's similar to the brute-force but it doesn't check\n\t\t\t  all possible combinations of graph edges but only all\n\t\t\t  combinations of nodes. "
						"It doesn't guarantee the\n\t\t\t  optimal solution but it still often finds it. "
						"It's\n\t\t\t  a lot faster than the brute-force but still very slow.\n"
			"\tcursory\t\t- It just takes all the possible nodes and edges from\n\t\t\t  the brute-force graph and then it tries to greedily\n\t\t\t  eliminate the ones that don't improve the solution.\n\t\t\t  "
						"It has comparable results to `exhaustive` and it is\n\t\t\t  significantly faster but generating the graph is still\n\t\t\t  too slow to handle over 10 inputs.\n"
			"\tgreedy\t\t- It doesn't create a graph but instead compares each 2\n\t\t\t  expressions and checks if they have common parts. It\n\t\t\t  just takes the first match. It's much faster than\n\t\t\t  `cursory` and it can handle mid-size inputs but not\n\t\t\t  the ones on the higher end of the size range.\n"
			"\n"
			"\n"
			"Input:\n"
			"The input format is similar to CSV but less constrained in some ways.\n"
			"It has the following format:\nINPUTS_DESCRIPTION <line-break> LIST_OF_FUNCTIONS\n"
			"- The description of inputs is either a list of their names or just their count.\n"
			"- The functions are separated by line breaks and are defined like this:\n  [NAME <line-break>] LIST_OF_MINTERMS <line-break> LIST_OF_DONT_CARES\n"
			"- Input names, minterms and don't-cares are lists of numbers separated by\n  whitespaces and/or and punctuation characters except \"-\", \"_\" and \"#\".\n  (A single dash may be used to indicate an empty list.)\n"
			"- Lines with any letters in them are considered to contain names.\n"
			"- Leading and trailing whitespaces are stripped as well as everything after the\n  \"#\" character (comments).\n"
			"- Blank lines and comment-only lines are ignored.\n"
			"\n"
			"An example of an input:\n"
			"\n"
			"\t# Notice various ways of separating the values.\n"
			"\t# (This is a comment btw; it will be ignored.)\n"
			"\ta, b, c, d\n"
			"\t\n"
			"\t Name of this function  # A valid name but bad name for generating code.\n"
			"\t  0; 5; 13  # Leading and training whitespaces are ignored.\n"
			"\t1; 2; 4; 15\n"
			"\t\n"
			"\t# Name is skipped for this one\n"
			"\t5 14\n"
			"\t0 1 3 4 7, 10;11 12 ,13 15  # You can mix different separators.\n"
		;
}

void printVersion()
{
	std::cout <<
			"karnaugh (Karnaugh Map Solver) version 0.3.0\n"
			"Author: Piotr Siupa\n"
#ifndef NDEBUG
			"This is a development build which contains additional assertions!\n"
			"(This may slow down the execution and increase the memory usage.)\n"
#endif
			;
}
